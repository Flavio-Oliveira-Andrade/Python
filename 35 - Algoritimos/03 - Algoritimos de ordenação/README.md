# O que vamos aprender ?
hoje vamos aprender o que s√£o **Algoritimos de ordena√ß√£o e algoritimos de busca** vamos implemanetar solu√ß√µes interaveis e recursivas
assim como aplicaremos o "dividir e conquistar" ou at√© mesmo a "for√ßa bruta". Faremos uma an√°lise de complexidade de cada um deles entendendo quando ser√° a melhor ocasi√£o para utiliz√°-los.

# sera capaz de;
- Implementar algorimos de busca cusca linear e busca binaria
- escrever algoritimo de ordena√ß√£o, como por exemplo, ordena√ß√£o por bolha , inser√ß√£o, sele√ß√£o com
- utilizar tecnicas de "for√ßa bruta" e "dividir para conquistar"
- Analisar a complexidade e escolher o algoritimo adequado para o problema

# Isso √© importante por ;
No dia a dia como pessoa programadora, voc√™ ser√° confrontada com diversos problemas. Seu papel ser√° analis√°-los e buscar uma solu√ß√£o eficiente. Se destacam aquelas pessoas que conseguem entender o problema e propor os melhores algoritmos para aquele caso. Por isso √© muito comum em entrevistas de emprego, empresas cobrarem o conhecimento destes algoritmos. N√£o quer dizer que na sua rotina de trabalho ir√° utilizar aqueles algoritmos o tempo todo, mas o conhecimento t√©cnico deles e as t√©cnicas empregadas em suas solu√ß√µes podem ser utilizadas em outras resolu√ß√µes.
O exerc√≠cio de analise de complexidade sobre estes algoritmos tamb√©m √© algo que deve ser destacado, pois √© algo bastante √∫til de ser aplicado em outros tipos de algoritmos.

## coteudo
### Algoritmos de Ordena√ß√£o
Algoritmo de ordena√ß√£o ( sorting algorithms ) s√£o uma categoria de algoritmos que buscam colocar elementos de uma sequ√™ncia em uma determinada ordem definida. Esta ordem pode ser num√©rica, lexicogr√°fica ou por qualquer outra caracter√≠stica. As raz√µes para se ordenar uma sequ√™ncia podem variar desde facilitar a visualiza√ß√£o at√© facilitar uma busca.
Imagine uma cole√ß√£o de m√∫sicas onde queremos exibi-las em ordem alfab√©tica, ou ordenadas pelo n√∫mero de vezes em que foram tocadas. Ou talvez uma lista telef√¥nica ao qual precisamos buscar um nome, n√£o seria mais f√°cil se estivesse ordenada em ordem alfab√©tica? Lidando com arrays, matrizes e outras cole√ß√µes, num√©ricas ou n√£o, muitas vezes teremos de utilizar a ordena√ß√£o.
Faremos a implementa√ß√£o e an√°lise de alguns dos algoritmos existentes (os mais populares). Existem v√°rios outros e basta uma busca por algoritmos de ordena√ß√£o ( sorting algorithms ) para obter uma lista extensa de algoritmos deste estilo.

### Algoritmos de ordena√ß√£o que usam for√ßa bruta

Como visto na aula anterior, a for√ßa bruta caracteriza-se por ser uma t√©cnica que se testa todas as possibilidades existentes para resolver um problema.
Por exemplo, imagine que voc√™ tem um cadeado com 4 d√≠gitos, cada um de 0-9. Voc√™ esqueceu sua combina√ß√£o, mas n√£o quer comprar outro cadeado. Como voc√™ n√£o consegue se lembrar de nenhum dos d√≠gitos, √© necess√°rio usar um m√©todo de for√ßa bruta para abrir a fechadura. Portanto, voc√™ define todos os n√∫meros de volta para 0 e os tenta um por um: 0001 , 0002 , 0003 e assim por diante at√© que seja aberto. Na pior das hip√≥teses, seriam necess√°rias 10‚Å¥ ou 10.000 tentativas para encontrar sua combina√ß√£o.

### Selection Sort
A ordena√ß√£o por sele√ß√£o ( selection sort em ingl√™s), divide o array em duas partes, uma j√° ordenada e outra de itens a serem ordenados. Em seguida, selecionaremos o menor elemento na lista n√£o ordenada e o incluiremos na lista ordenada. Isto ser√° feito continuamente at√© que nossa lista de elementos n√£o ordenados se esgote, e logo teremos uma lista com os itens ordenados.
Como funciona o algoritmo?

```
# Vamos supor os n√∫meros n√£o ordenados
- ordenados =
- n√£o ordenados = 3 6 1 7

# Buscamos entre os elementos n√£o ordenados o menor elemento
- menor = 1

# Vamos adicion√°-lo a lista de elementos ordenados
- ordenados = 1
- n√£o ordenados = 6 3 7

# Agora repetimos o passo de busca
- menor = 3

# Assim teremos
- ordenados = 1 3
- n√£o ordenados = 6 7

# Como ainda n√£o esgotamos os n√∫meros a serem ordenados repetiremos a busca
menor = 6

# Agora temos quase todos os elementos ordenados
- ordenados = 1 3 6
- n√£o ordenados = 7

# Faremos a busca pelo menor elemento novamente (√∫nico)
- menor = 7

# Esgotamos as possibilidades e temos nossa lista ordenada
- ordenados = 1 3 6 7
```
Vamos ver um exemplo de implementa√ß√£o:

```
def selection_sort(array):
    # como um algoritmo de for√ßa bruta
    # percorre a estrutura exaustivamente
    for i in range(len(array)):
        minimum = i

        # itera sobre os elementos n√£o ordenados
        for j in range(i + 1, len(array)):
            # seleciona o menor valor
            if array[j] < array[minimum]:
                minimum = j

        # ap√≥s encontrar o menor valor
        # ao inv√©s de criar um novo array (o que aumenta complexidade de espa√ßo)
        # realizamos a substitui√ß√£o entre o menor elemento
        # e a posi√ß√£o i que corresponde ao primeiro elemento n√£o ordenado
        # que consequentemente passar√° a ser o √∫ltimo ordenado
        array[minimum], array[i] = array[i], array[minimum]

    return array

print(selection_sort([100, 4, 6, 33, 56, 67]))
```
Analisando a complexidade deste algoritmo, vemos que independente de todos os elementos estarem ordenados (ou n√£o), ou parcialmente ordenados, sempre teremos que percorrer o array completamente e tamb√©m n - 1 elementos a cada itera√ß√£o. Isto nos leva a uma complexidade O(n¬≤) para todos os casos (pior, m√©dio, melhor).
Como criamos apenas algumas vari√°veis de controle e n√£o criamos um array auxiliar, nosso algoritmo tem uma complexidade de espa√ßo constante, ou seja, n√£o muda seja para 10, 1000 ou 10.000 elementos.

#### Insertion Sort
A ordena√ß√£o por inser√ß√£o ( insertion sort ), tem esse nome por inserir um elemento de cada vez em sua posi√ß√£o correta. Fazendo uma analogia a um jogo de cartas, onde sua "m√£o" esteja ordenada, √© como se a cada nova carta recebida fossemos movendo ela at√© achar a posi√ß√£o correta e a inserimos ali, e faremos isso sucessivamente at√© que n√£o tenha novas cartas e por consequ√™ncia, nossa m√£o esteja ordenada. √â mais eficiente que a ordena√ß√£o por sele√ß√£o e tamb√©m considerada mais simples.
Como funciona o algoritmo?

```
# Vamos supor os n√∫meros n√£o ordenados
- cole√ß√£o = 3 2 1 7

# vamos pegar o primeiro elemento e mov√™-lo at√© sua posi√ß√£o
- elemento = 3

# como n√£o h√° elementos a esquerda de 3 n√£o o movemos
- cole√ß√£o = 3 2 1 7

# agora vamos pegar o segundo elemento
- elemento = 2

# vamos mov√™-lo √† esquerda, enquanto seu valor for menor
# que o elemento a sua esquerda
             ‚§∫
- cole√ß√£o = 2 3 1 7

# pr√≥ximo elemento da cole√ß√£o
- elemento = 1

# vamos inseri-lo na  posi√ß√£o correta,
# movendo para a esquerda enquanto seu valor for menor
# que o elemento a esquerda
             ‚§∫ ‚§∫
- cole√ß√£o = 1 2 3 7

# por fim verificamos o √∫ltimo elemento
- elemento = 7

# n√£o h√° elementos menores a esquerda
# e a cole√ß√£o est√° ordenada
- cole√ß√£o = 1 2 3 7
```

Vamos ver um exemplo de implementa√ß√£o:

```
def insertion_sort(array):
    # itera sobre cada valor do array
    for i in range(len(array)):
        current_value = array[i]
        current_position = i
        # enquanto o valor da posi√ß√£o for menor que os elementos a sua esquerda
        while (
            current_position > 0
            and array[current_position - 1] > current_value
        ):
            # move as posi√ß√µes para a direita
            array[current_position] = array[current_position - 1]
            current_position = current_position - 1
        # colocamos o elemento em sua nova posi√ß√£o
        array[current_position] = current_value
    return array

print(insertion_sort([100, 4, 6, 33, 56, 67]))
```
Como precisamos percorrer cada um dos elementos, e depois percorrer comparando os elementos √† esquerda do mesmo, em um pior caso, onde o array esteja inversamente ordenado, teremos uma complexidade de O(n¬≤) . Isto se repete tamb√©m em m√©dia, para arrays parcialmente ordenados. Por√©m se inicialmente o array estiver ordenado, este algoritmo ter√° complexidade O(n) , pois s√≥ fara a itera√ß√£o de todos os elementos, e n√£o precisar√° ficar movendo os elementos.
Assim como na ordena√ß√£o por sele√ß√£o, como criamos apenas algumas vari√°veis de controle e n√£o criamos um array auxiliar, nosso algoritmo tem uma complexidade de espa√ßo constante, ou seja, n√£o muda, seja para 10, 1000 ou 10.000 elementos.

#### Algoritmos de ordena√ß√£o que usam solu√ß√µes iterativas

Solu√ß√µes iterativas consistem na realiza√ß√£o de uma ou mais opera√ß√µes repetidas vezes, por meios de comandos de repeti√ß√£o. As ordena√ß√µes demonstradas acima (sele√ß√£o, inser√ß√£o), s√£o consideradas iterativas, pois estamos realizando opera√ß√µes de compara√ß√£o e troca de elementos repetidas vezes, por meios de comandos de repeti√ß√£o ( for ).
üí° Toda solu√ß√£o iterativa pode ser reescrita de forma recursiva.

### Bubble Sort
amb√©m conhecido como ordena√ß√£o por bolha ( bubble sort ), t√™m esse nome, pois a movimenta√ß√£o dos elementos lembra o movimento das bolhas em um refrigerante. S√£o realizadas m√∫ltiplas itera√ß√µes sobre a cole√ß√£o, sempre comparando o valor ao item adjacente e realizando a troca daqueles que est√£o fora de ordem. A cada itera√ß√£o o pr√≥ximo maior valor √© colocado em sua posi√ß√£o correta, ou seja, cada item se desloca como uma bolha para a posi√ß√£o a qual pertence.
Como funciona o algoritmo?

```
# Vamos supor os n√∫meros n√£o ordenados
- cole√ß√£o = 7 5 1 2

# vamos realizar a primeira itera√ß√£o.
# Comparamos os dois primeiros elementos (√≠ndices 0 e 1)
- 7 > 5 ?

# como o 7 √© maior 5, faremos a troca de posi√ß√£o

           ‚§∫
- cole√ß√£o = 5 7 1 2
           ‚§ª
# Agora comparamos os elementos dos √≠ndices 1 e 2

- 7 > 1?

# Novamente faremos a troca
             ‚§∫
- cole√ß√£o = 5 1 7 2
             ‚§ª

# Depois, comparamos os √≠ndices 2 e 3

- 7 > 2

# Mais uma vez faremos a troca
               ‚§∫
- cole√ß√£o = 5 1 2 7
               ‚§ª

# Como houveram trocas, vamos iterar mais uma vez nossa cole√ß√£o
# O elemento 7, como uma bolha, foi subindo at√© sua posi√ß√£o
- cole√ß√£o = 5 1 2 7

# Comparamos os primeiros elementos e faremos a troca
           ‚§∫
- cole√ß√£o = 1 5 2 7
           ‚§ª

# Em seguida comparamos os pr√≥ximos elementos e faremos a troca novamente

             ‚§∫
- cole√ß√£o = 1 2 5 7
             ‚§ª
# Como houveram trocas precisamos iterar novamente a nossa cole√ß√£o
- cole√ß√£o = 1 2 5 7

# Por√©m desta vez n√£o h√° trocas e nossa cole√ß√£o est√° ordenada
```

```
def bubble_sort(array):
    # vari√°vel utilizado na itera√ß√£o
    # para marcar se houve ou n√£o trocas naquela itera√ß√£o
    # Quando falsa, indica que o array est√° ordenado
    has_swapped = True

    # armazena o n√∫mero de itera√ß√µes para evitar
    # a itera√ß√£o sobre √≠ndices j√° ordenados
    num_of_iterations = 0

    # Enquanto ainda n√£o est√° ordenado (ocorreram trocas na itera√ß√£o)
    while has_swapped:
        has_swapped = False

        # percorra o array at√© o ultimo √≠ndice n√£o ordenado
        for i in range(len(array) - num_of_iterations - 1):
            # caso a posi√ß√£o corrente seja maior que a posterior
            if array[i] > array[i + 1]:
                # realiza a troca entre as posi√ß√µes
                array[i], array[i + 1] = array[i + 1], array[i]
                # marca que tivemos trocas nesta itera√ß√£o
                has_swapped = True
        num_of_iterations += 1

    return array


print(bubble_sort([100, 4, 6, 33, 56, 67]))
```
### Algoritmos de ordena√ß√£o que usam dividir e conquistar
Algoritmos que utilizam da t√©cnica de dividir e conquistar , consistem em dividir um problema grande em partes menores, encontrar solu√ß√µes para as partes menores, e ent√£o combinar as solu√ß√µes obtidas em uma solu√ß√£o global. Esta t√©cnica produz um algoritmo eficiente, caso a divis√£o e conquista sejam eficientes.
üí° Os algoritmos abaixo foram implementados de forma recursiva, mas lembre-se, toda solu√ß√£o recursiva pode ser reescrita de forma iterativa.

### Merge sort

